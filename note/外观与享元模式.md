## 外观模式

### 定义

外部与个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

#### 动机

引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。



<img src="C:\Users\SYyx1\AppData\Roaming\Typora\typora-user-images\image-20200322212756666.png" alt="image-20200322212756666" style="zoom:67%;" />

### 角色：

Facade外观角色。
       SubSystem:子系统角色

### 模式分析

根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。

外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。

### 优点

对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
		降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
		只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

### 缺点

不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
		在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
场景。
		当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。
		客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
		在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

### 场景

当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。
		客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
		在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。

### 使用注意点

可能一般以单例形式存在，即在系统中就只一个外观对象
		不要让外观类对象承担过多的“额外”的工作，也不要企图继承外观类增加扩展它的功能，本身的功能点必须在各子系统完成，“各回各家”。



<img src="C:\Users\SYyx1\AppData\Roaming\Typora\typora-user-images\image-20200322213155775.png" alt="image-20200322213155775" style="zoom:67%;" />

<img src="C:\Users\SYyx1\AppData\Roaming\Typora\typora-user-images\image-20200322214039453.png" alt="image-20200322214039453" style="zoom:67%;" />



### 总结

外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。
		外观模式的目的在于降低系统的复杂程度。
		外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。



# 享元模式



### 定义

享元模式（Flyweight Pattern):运用共享技术有效地支持大量细粒度对象的复用。动机
		面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。
		享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。
		在享元模式中可以共享的相同内容称为内部状态（Intrinsic-State)，而那些需要外部环境来设置的不能共享的内容称为外部状态（Extrinsic-State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。.
		在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池
（Flyweight-Pool)用于存储具有相同内部状态的享元对象。

<img src="C:\Users\SYyx1\AppData\Roaming\Typora\typora-user-images\image-20200322214613360.png" alt="image-20200322214613360" style="zoom:67%;" />

特点与优点
系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复
用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是
一种对象结构型模式。
享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高
系统的性能。
大大减少了对象的创建，降低了程序内存的占用，提高效率，
缺点
提高了系统的复杂度。需要分离出内部状态和外都状态，而外部状态具有固化特性，不
应该随着内部状态的改变而改变
使用场景
系统中有大量对象时。
这些对象消耗大量内存时。
这些对象的状态大部分可以外部化时。
系统中存在大量相似对象
需要缓冲池的场景。

方法
用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用
HashMap/HashTable存储
应用实例
String常量池
数据库连接池。
注意事项
注意划分内部状态和外部状态，否则可能会引起线程安全问题。
这些类必须有一个工厂类加以控制。